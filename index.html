<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Neon Nodes</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Comfortaa:wght@300;700&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #0f0c29;
            font-family: 'Comfortaa', sans-serif;
            touch-action: none; /* Disables browser zooming/scrolling */
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            padding-top: max(20px, env(safe-area-inset-top)); /* Notch support */
            box-sizing: border-box;
            z-index: 10;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 10px 25px;
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-align: center;
            align-self: flex-start;
        }

        #score-label {
            font-size: 0.75rem;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 2px;
        }

        #score {
            font-size: 1.8rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        /* Start Overlay */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a2e, #000);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 999;
            transition: opacity 0.5s ease;
        }

        #overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            color: #fff;
            font-size: 3rem;
            margin: 0 0 10px 0;
            text-align: center;
            text-shadow: 0 0 20px #00d2ff, 0 0 40px #3a7bd5;
        }

        p.subtitle {
            color: #a2a2a2;
            font-size: 1.1rem;
            margin-bottom: 50px;
            text-align: center;
        }

        #startBtn {
            background: transparent;
            color: #fff;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 18px 50px;
            font-size: 1.2rem;
            border-radius: 50px;
            font-family: 'Comfortaa', sans-serif;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: transform 0.1s, border-color 0.3s, box-shadow 0.3s;
        }

        #startBtn::before {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            opacity: 0.2;
            z-index: -1;
        }

        #startBtn:active {
            transform: scale(0.95);
            background: rgba(255,255,255,0.1);
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="score-box">
            <div id="score-label">Score</div>
            <div id="score">0</div>
        </div>
    </div>

    <div id="overlay">
        <h1>Neon Nodes</h1>
        <p class="subtitle">Connect. Relax. Flow.</p>
        <button id="startBtn">START</button>
    </div>

<script>
/**
 * AUDIO SYSTEM
 * Robust implementation with try/catch to prevent game crashes.
 */
const AudioSys = {
    ctx: null,
    master: null,
    delay: null,
    isInit: false,
    nextNoteTime: 0,
    
    // Pentatonic Scale frequencies
    scale: [261.63, 311.13, 349.23, 392.00, 466.16, 523.25], 

    init() {
        if (this.isInit) return;
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (!AudioContext) return; // Audio not supported, play silent
            
            this.ctx = new AudioContext();
            
            // Master Volume
            this.master = this.ctx.createGain();
            this.master.gain.value = 0.3;
            this.master.connect(this.ctx.destination);

            // Delay Effect (Echo)
            this.delay = this.ctx.createDelay();
            this.delay.delayTime.value = 0.4;
            const feedback = this.ctx.createGain();
            feedback.gain.value = 0.3;
            this.delay.connect(feedback);
            feedback.connect(this.delay);
            this.delay.connect(this.master);

            this.isInit = true;
            this.nextNoteTime = this.ctx.currentTime + 0.5;
            this.schedule();
            
        } catch (e) {
            console.warn("Audio init failed, playing silent mode.", e);
        }
    },

    resume() {
        if (this.ctx && this.ctx.state === 'suspended') {
            this.ctx.resume().catch(e => console.log(e));
        }
    },

    schedule() {
        if (!this.ctx) return;
        // Schedule ahead
        const lookahead = 0.1; 
        
        // Safety break if tab is backgrounded
        if (this.ctx.state === 'suspended') {
            requestAnimationFrame(() => this.schedule());
            return;
        }

        while (this.nextNoteTime < this.ctx.currentTime + lookahead) {
            this.playAmbient(this.nextNoteTime);
            this.nextNoteTime += Math.random() * 2 + 1.5; // Slow ambient pace
        }
        requestAnimationFrame(() => this.schedule());
    },

    playAmbient(time) {
        try {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            // Random note
            const freq = this.scale[Math.floor(Math.random() * this.scale.length)];
            osc.frequency.value = freq;
            osc.type = 'sine';

            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.1, time + 1.0); // Slow attack
            gain.gain.exponentialRampToValueAtTime(0.001, time + 4.0); // Long release

            osc.connect(gain);
            gain.connect(this.master);
            gain.connect(this.delay);
            
            osc.start(time);
            osc.stop(time + 5.0);
        } catch(e) {}
    },

    playPop(pitchIndex) {
        if (!this.ctx) return;
        this.resume();
        try {
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            // Pitch goes up with chain length
            const base = 400;
            osc.frequency.setValueAtTime(base + (pitchIndex * 50), t);
            osc.type = 'triangle';

            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.15, t + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

            osc.connect(gain);
            gain.connect(this.master);
            osc.start(t);
            osc.stop(t + 0.3);
        } catch(e) {}
    },

    playSuccess() {
        if (!this.ctx) return;
        try {
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.frequency.setValueAtTime(300, t);
            osc.frequency.linearRampToValueAtTime(800, t + 0.2);
            osc.type = 'sine';

            gain.gain.setValueAtTime(0.2, t);
            gain.gain.linearRampToValueAtTime(0, t + 0.4);

            osc.connect(gain);
            gain.connect(this.master);
            gain.connect(this.delay);
            osc.start(t);
            osc.stop(t + 0.4);
        } catch(e) {}
    }
};

/**
 * GRAPHICS & GAME LOGIC
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });
const scoreEl = document.getElementById('score');

// Settings
let dpr = window.devicePixelRatio || 1;
let W, H;
let COLS = 6, ROWS = 8;
let TILE_SIZE = 0;
let OFF_X = 0, OFF_Y = 0;
let time = 0;

const THEMES = [
    { c: '#ff0055', g: '#ff6b9d' }, // Red/Pink
    { c: '#00eaff', g: '#80f4ff' }, // Cyan
    { c: '#ffcc00', g: '#ffeeb0' }, // Gold
    { c: '#aa00ff', g: '#dcaaff' }, // Purple
    { c: '#00ff66', g: '#9effc5' }  // Green
];

// State
let grid = [];
let particles = [];
let chain = [];
let isDragging = false;
let score = 0;
let isGameRunning = false;

// Entities
class Orb {
    constructor(c, r) {
        this.c = c; this.r = r;
        this.type = Math.floor(Math.random() * THEMES.length);
        this.x = c * TILE_SIZE + TILE_SIZE/2;
        this.y = -100; // Spawn high
        this.ty = r * TILE_SIZE + TILE_SIZE/2;
        this.vy = 0;
        this.scale = 1;
    }
    update() {
        this.ty = this.r * TILE_SIZE + TILE_SIZE/2;
        // Gravity / Physics
        const dy = this.ty - this.y;
        if (Math.abs(dy) > 1) {
            this.vy += 1;
            this.y += this.vy;
            // Floor bounce
            if (this.y > this.ty) {
                this.y = this.ty;
                this.vy *= -0.3;
            }
        } else {
            this.y = this.ty;
            this.vy = 0;
        }

        // Selection effect
        if (chain.includes(this)) {
            this.scale = 1.2 + Math.sin(time * 0.2) * 0.1;
        } else {
            this.scale += (1 - this.scale) * 0.1;
        }
    }
    draw(c) {
        const cx = this.x + OFF_X;
        const cy = this.y + OFF_Y;
        const r = (TILE_SIZE * 0.38) * this.scale;
        const theme = THEMES[this.type];

        // Glow
        c.shadowBlur = 15;
        c.shadowColor = theme.c;
        
        // Core
        c.fillStyle = theme.c;
        c.beginPath();
        c.arc(cx, cy, r, 0, Math.PI*2);
        c.fill();

        // Highlight (Glass effect)
        c.shadowBlur = 0;
        c.fillStyle = 'rgba(255,255,255,0.5)';
        c.beginPath();
        c.arc(cx - r*0.3, cy - r*0.3, r*0.25, 0, Math.PI*2);
        c.fill();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y; this.color = color;
        const a = Math.random() * 6.28;
        const s = Math.random() * 5 + 2;
        this.vx = Math.cos(a) * s;
        this.vy = Math.sin(a) * s;
        this.life = 1;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2;
        this.life -= 0.04;
    }
    draw(c) {
        c.globalAlpha = Math.max(0, this.life);
        c.fillStyle = this.color;
        c.beginPath();
        c.arc(this.x, this.y, 4, 0, Math.PI*2);
        c.fill();
        c.globalAlpha = 1;
    }
}

// Core Functions
function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * dpr;
    canvas.height = H * dpr;
    ctx.scale(dpr, dpr);

    TILE_SIZE = Math.min(W / COLS, H / (ROWS + 2));
    const gw = TILE_SIZE * COLS;
    const gh = TILE_SIZE * ROWS;
    OFF_X = (W - gw) / 2;
    OFF_Y = (H - gh) / 2 + TILE_SIZE;
}

function initGrid() {
    grid = [];
    for(let c=0; c<COLS; c++){
        let col = [];
        for(let r=0; r<ROWS; r++){
            col.push(new Orb(c, r));
        }
        grid.push(col);
    }
}

function getPos(e) {
    const touch = e.touches ? e.touches[0] : e;
    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;
    
    // Map to grid
    const rx = x - OFF_X;
    const ry = y - OFF_Y;
    
    if (rx < 0 || rx > COLS*TILE_SIZE || ry < 0 || ry > ROWS*TILE_SIZE) return null;
    
    return {
        c: Math.floor(rx / TILE_SIZE),
        r: Math.floor(ry / TILE_SIZE)
    };
}

// Input Logic
function inputStart(e) {
    e.preventDefault();
    if (!isGameRunning) return;
    isDragging = true;
    AudioSys.resume();
    
    const p = getPos(e);
    if (!p) return;
    const orb = grid[p.c][p.r];
    if (orb) {
        chain = [orb];
        AudioSys.playPop(0);
        // Haptics
        if(navigator.vibrate) navigator.vibrate(5);
    }
}

function inputMove(e) {
    e.preventDefault();
    if (!isDragging) return;
    
    const p = getPos(e);
    if (!p) return;
    const orb = grid[p.c][p.r];
    if (!orb) return;

    const last = chain[chain.length-1];
    
    // Backtrack
    if (chain.length > 1 && chain[chain.length-2] === orb) {
        chain.pop();
        AudioSys.playPop(chain.length);
        return;
    }

    // Connect
    if (orb !== last && orb.type === last.type && !chain.includes(orb)) {
        // Check adjacency (diagonal ok)
        const dc = Math.abs(orb.c - last.c);
        const dr = Math.abs(orb.r - last.r);
        if (dc <= 1 && dr <= 1) {
            chain.push(orb);
            AudioSys.playPop(chain.length);
            if(navigator.vibrate) navigator.vibrate(8);
        }
    }
}

function inputEnd(e) {
    if(e && e.preventDefault) e.preventDefault();
    isDragging = false;
    
    if (chain.length >= 3) {
        // Success
        score += chain.length * 10;
        scoreEl.textContent = score;
        AudioSys.playSuccess();
        if(navigator.vibrate) navigator.vibrate([10, 30]);

        // Particles & Clear
        chain.forEach(o => {
            const cx = o.x + OFF_X;
            const cy = o.y + OFF_Y;
            for(let i=0; i<5; i++) particles.push(new Particle(cx, cy, THEMES[o.type].c));
            grid[o.c][o.r] = null;
        });

        // Drop
        for(let c=0; c<COLS; c++) {
            let nextR = ROWS-1;
            for(let r=ROWS-1; r>=0; r--) {
                if(grid[c][r]) {
                    let temp = grid[c][r];
                    grid[c][r] = null;
                    grid[c][nextR] = temp;
                    temp.r = nextR;
                    nextR--;
                }
            }
            // Spawn
            for(let r=nextR; r>=0; r--) {
                const o = new Orb(c, r);
                o.y = -200 - (Math.random()*200);
                grid[c][r] = o;
            }
        }
    }
    chain = [];
}

// Loop
function loop() {
    requestAnimationFrame(loop);
    time++;
    
    // BG
    ctx.fillStyle = '#0f0c29';
    ctx.fillRect(0, 0, W, H);
    
    // Draw Line
    if (chain.length > 1) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = TILE_SIZE * 0.15;
        ctx.strokeStyle = THEMES[chain[0].type].c;
        ctx.shadowBlur = 20;
        ctx.shadowColor = ctx.strokeStyle;
        
        ctx.beginPath();
        chain.forEach((o, i) => {
            const cx = o.x + OFF_X;
            const cy = o.y + OFF_Y;
            if(i===0) ctx.moveTo(cx, cy);
            else ctx.lineTo(cx, cy);
        });
        ctx.stroke();
        ctx.shadowBlur = 0;
    }

    // Orbs
    for(let c=0; c<COLS; c++){
        for(let r=0; r<ROWS; r++){
            if(grid[c][r]) {
                grid[c][r].update();
                grid[c][r].draw(ctx);
            }
        }
    }

    // Particles
    for(let i=particles.length-1; i>=0; i--){
        particles[i].update();
        particles[i].draw(ctx);
        if(particles[i].life <= 0) particles.splice(i, 1);
    }
}

// Setup
window.addEventListener('resize', resize);
resize();
initGrid();

// Start Logic
const btn = document.getElementById('startBtn');
const overlay = document.getElementById('overlay');

function startGame(e) {
    if(e) e.preventDefault();
    if(isGameRunning) return; // prevent double start
    
    overlay.classList.add('hidden');
    isGameRunning = true;
    
    AudioSys.init(); // Try to start audio
    loop(); // Start visual loop
}

btn.addEventListener('click', startGame);
btn.addEventListener('touchstart', startGame, {passive: false});

// Game Inputs
canvas.addEventListener('mousedown', inputStart);
canvas.addEventListener('mousemove', inputMove);
canvas.addEventListener('mouseup', inputEnd);

canvas.addEventListener('touchstart', inputStart, {passive: false});
canvas.addEventListener('touchmove', inputMove, {passive: false});
canvas.addEventListener('touchend', inputEnd, {passive: false});

</script>
</body>
</html>